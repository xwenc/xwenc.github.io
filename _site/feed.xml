<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-02-01T14:10:27+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Andy Xiong’s Notes</title><subtitle>You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.
</subtitle><author><name>Andy Xiong</name></author><entry><title type="html">How to develop a blog using dotnet mvc</title><link href="http://localhost:4000/2020/12/04/dotnet-blog.html" rel="alternate" type="text/html" title="How to develop a blog using dotnet mvc" /><published>2020-12-04T00:00:00+08:00</published><updated>2020-12-04T00:00:00+08:00</updated><id>http://localhost:4000/2020/12/04/dotnet-blog</id><content type="html" xml:base="http://localhost:4000/2020/12/04/dotnet-blog.html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/tutorials/dotnet-watch?view=aspnetcore-5.0&quot;&gt;Develop ASP.NET Core apps using a file watcher&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="dotnet" /><summary type="html">Develop ASP.NET Core apps using a file watcher</summary></entry><entry><title type="html">C#语言入门详解(014)——表达式，语句详解（2）</title><link href="http://localhost:4000/2020/10/12/c-sharp-basic-014.html" rel="alternate" type="text/html" title="C#语言入门详解(014)——表达式，语句详解（2）" /><published>2020-10-12T00:00:00+08:00</published><updated>2020-10-12T00:00:00+08:00</updated><id>http://localhost:4000/2020/10/12/c-sharp-basic-014</id><content type="html" xml:base="http://localhost:4000/2020/10/12/c-sharp-basic-014.html">&lt;h2 id=&quot;语句详解&quot;&gt;语句详解&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;声明语句&lt;/li&gt;
  &lt;li&gt;表达式语句&lt;/li&gt;
  &lt;li&gt;块语句&lt;/li&gt;
  &lt;li&gt;选择（判断、分支）语句&lt;/li&gt;
  &lt;li&gt;迭代（循环） 语句&lt;/li&gt;
  &lt;li&gt;跳转 语句&lt;/li&gt;
  &lt;li&gt;try.. catch … finally 语句&lt;/li&gt;
  &lt;li&gt;using 语句&lt;/li&gt;
  &lt;li&gt;yield 语句&lt;/li&gt;
  &lt;li&gt;checked/unchecked 语句&lt;/li&gt;
  &lt;li&gt;lock 语句(用于多线程)&lt;/li&gt;
  &lt;li&gt;标签语句&lt;/li&gt;
  &lt;li&gt;空语句&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="csharp" /><summary type="html">语句详解 声明语句 表达式语句 块语句 选择（判断、分支）语句 迭代（循环） 语句 跳转 语句 try.. catch … finally 语句 using 语句 yield 语句 checked/unchecked 语句 lock 语句(用于多线程) 标签语句 空语句</summary></entry><entry><title type="html">Using ActionCable and Stimulus to remotely update partials</title><link href="http://localhost:4000/2020/10/09/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6.html" rel="alternate" type="text/html" title="Using ActionCable and Stimulus to remotely update partials" /><published>2020-10-09T00:00:00+08:00</published><updated>2020-10-09T00:00:00+08:00</updated><id>http://localhost:4000/2020/10/09/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6</id><content type="html" xml:base="http://localhost:4000/2020/10/09/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6.html">&lt;p&gt;&lt;a href=&quot;https://mikerogers.io/2019/09/16/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6&quot;&gt;https://mikerogers.io/2019/09/16/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6&lt;/a&gt;&lt;/p&gt;</content><author><name>Andy Xiong</name></author><category term="rails" /><summary type="html">https://mikerogers.io/2019/09/16/using-actioncable-and-stimulus-to-remotely-update-partials-in-rails-6</summary></entry><entry><title type="html">C#语言入门详解(013)——表达式，语句详解（1）</title><link href="http://localhost:4000/2020/10/01/c-sharp-basic-013.html" rel="alternate" type="text/html" title="C#语言入门详解(013)——表达式，语句详解（1）" /><published>2020-10-01T00:00:00+08:00</published><updated>2020-10-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/10/01/c-sharp-basic-013</id><content type="html" xml:base="http://localhost:4000/2020/10/01/c-sharp-basic-013.html">&lt;h2 id=&quot;表达式的定义&quot;&gt;表达式的定义&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;什么是表达式&lt;/li&gt;
  &lt;li&gt;表达式、命令、声明是一门计算机语言的基本组件，我们可以说是表达式是任何一门语言的最重要的组件。&lt;/li&gt;
  &lt;li&gt;表达式是一个语法实体，它的功能是用来求值，要么成功要么失败，如果成功会有一个返回值，如果失败有一个错误的返回值，表达式是用来求值的表达实体&lt;/li&gt;
  &lt;li&gt;各种编程语言对表达式的实现不尽相同，但大体上都符合这个定义&lt;/li&gt;
  &lt;li&gt;C#语言对表达式的定义&lt;/li&gt;
  &lt;li&gt;C#的表达式是有一个或多个操作数和0或多个操作符组成的序列，表达式的求值得到的结果有可能是single value, object, method or namespace.   表达式有可能是由字面值，方法调用，操作符和操作数或者是个simple name. simple name 有可能是变量， 或者类型成员， 也有可能是方法的参数或命名空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;各类表达式概览&quot;&gt;各类表达式概览&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;C#语言中表达式的分类&lt;/li&gt;
  &lt;li&gt;A value. Every value has an associated type. 任何能得到值的运算（回顾操作符和结果类型）&lt;/li&gt;
  &lt;li&gt;A variable. Every variable has an associated type.&lt;/li&gt;
  &lt;li&gt;A namespace.&lt;/li&gt;
  &lt;li&gt;A type.&lt;/li&gt;
  &lt;li&gt;A method group. 例如：Console.WriteLine, 这是一组方法， 重载决策决定具体调用哪个&lt;/li&gt;
  &lt;li&gt;A null literal.&lt;/li&gt;
  &lt;li&gt;An anonymous function.&lt;/li&gt;
  &lt;li&gt;A property access.&lt;/li&gt;
  &lt;li&gt;An event access.&lt;/li&gt;
  &lt;li&gt;An indexer access.&lt;/li&gt;
  &lt;li&gt;Nothing. 对返回值为void的方法的调用&lt;/li&gt;
  &lt;li&gt;复合表达式的求值&lt;/li&gt;
  &lt;li&gt;注意操作符的优先级和同优先级操作符的运算方向&lt;/li&gt;
  &lt;li&gt;参考C#语言定义文档&lt;/li&gt;
  &lt;li&gt;仅作参考，不必深究–毕竟我们是在学习语言、不是去实现这门语言 
 *&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="csharp" /><summary type="html">表达式的定义 什么是表达式 表达式、命令、声明是一门计算机语言的基本组件，我们可以说是表达式是任何一门语言的最重要的组件。 表达式是一个语法实体，它的功能是用来求值，要么成功要么失败，如果成功会有一个返回值，如果失败有一个错误的返回值，表达式是用来求值的表达实体 各种编程语言对表达式的实现不尽相同，但大体上都符合这个定义 C#语言对表达式的定义 C#的表达式是有一个或多个操作数和0或多个操作符组成的序列，表达式的求值得到的结果有可能是single value, object, method or namespace. 表达式有可能是由字面值，方法调用，操作符和操作数或者是个simple name. simple name 有可能是变量， 或者类型成员， 也有可能是方法的参数或命名空间。</summary></entry><entry><title type="html">Australia dots map</title><link href="http://localhost:4000/2020/09/28/d3-aus-map.html" rel="alternate" type="text/html" title="Australia dots map" /><published>2020-09-28T00:00:00+08:00</published><updated>2020-09-28T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/28/d3-aus-map</id><content type="html" xml:base="http://localhost:4000/2020/09/28/d3-aus-map.html">&lt;p&gt;&lt;a href=&quot;https://bl.ocks.org/GerardoFurtado/02aa65e5522104cb692e&quot;&gt;https://bl.ocks.org/GerardoFurtado/02aa65e5522104cb692e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://observablehq.com/@hzschie/dots-on-map&quot;&gt;https://observablehq.com/@hzschie/dots-on-map&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codepen.io/shshaw/pen/vJNMQY&quot;&gt;https://codepen.io/shshaw/pen/vJNMQY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.d3-graph-gallery.com/graph/bubblemap_tooltip.html&quot;&gt;https://www.d3-graph-gallery.com/graph/bubblemap_tooltip.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Andy Xiong</name></author><category term="animate" /><summary type="html">https://bl.ocks.org/GerardoFurtado/02aa65e5522104cb692e</summary></entry><entry><title type="html">C#语言入门详解(011)——操作符详解（下）</title><link href="http://localhost:4000/2020/09/28/c-sharp-basic-012.html" rel="alternate" type="text/html" title="C#语言入门详解(011)——操作符详解（下）" /><published>2020-09-28T00:00:00+08:00</published><updated>2020-09-28T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/28/c-sharp-basic-012</id><content type="html" xml:base="http://localhost:4000/2020/09/28/c-sharp-basic-012.html">&lt;h2 id=&quot;类型转换&quot;&gt;类型转换&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;隐式(implicit)类型转换， 转换列表 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;不丢失精度的转换&lt;/li&gt;
  &lt;li&gt;子类向父类的转换&lt;/li&gt;
  &lt;li&gt;装箱&lt;/li&gt;
  &lt;li&gt;显式(explicit)类型转换&lt;/li&gt;
  &lt;li&gt;有可能丢失精度(甚至发生错误)的转换, 即cast&lt;/li&gt;
  &lt;li&gt;拆箱&lt;/li&gt;
  &lt;li&gt;使用Convert类&lt;/li&gt;
  &lt;li&gt;ToString方法与各数据类型的Parse/TryParse方法&lt;/li&gt;
  &lt;li&gt;自定义类型转换操作符&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;乘法操作符&quot;&gt;乘法操作符&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数据类型提升&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;位操作符&quot;&gt;位操作符&lt;/h2&gt;
&lt;p&gt;按位求与 &amp;amp; 二进制 0为假 1 为真，按位求或 |， 两位有一个为真就为真，  两位异或 ^, 两位相同为真否则为假。都是操作二进制用的&lt;/p&gt;

&lt;p&gt;## 逻辑操作符
短路效应&lt;/p&gt;</content><author><name>Andy Xiong</name></author><category term="csharp" /><summary type="html">类型转换 隐式(implicit)类型转换， 转换列表 https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions 不丢失精度的转换 子类向父类的转换 装箱 显式(explicit)类型转换 有可能丢失精度(甚至发生错误)的转换, 即cast 拆箱 使用Convert类 ToString方法与各数据类型的Parse/TryParse方法 自定义类型转换操作符</summary></entry><entry><title type="html">C#语言入门详解(011)——操作符详解（中）</title><link href="http://localhost:4000/2020/09/24/c-sharp-basic-011.html" rel="alternate" type="text/html" title="C#语言入门详解(011)——操作符详解（中）" /><published>2020-09-24T00:00:00+08:00</published><updated>2020-09-24T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/24/c-sharp-basic-011</id><content type="html" xml:base="http://localhost:4000/2020/09/24/c-sharp-basic-011.html">&lt;h2 id=&quot;操作符示例&quot;&gt;操作符示例&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基本操作符
    &lt;ul&gt;
      &lt;li&gt;new  功能强大， 不能乱使用， 会造成紧耦合，依赖注入模式可以把紧耦合变成比较松的耦合， 也可以作为修饰符使用&lt;/li&gt;
      &lt;li&gt;checked, unchecked   检查是否溢出&lt;/li&gt;
      &lt;li&gt;sizeof 获取基本数据类型在内存中所占的字节&lt;/li&gt;
      &lt;li&gt;-&amp;gt; 箭头符号  通过指针的间接访问&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一元操作符&lt;/li&gt;
  &lt;li&gt;&amp;amp;* 取地址符号和取引用符号&lt;/li&gt;
  &lt;li&gt;“ +   - ！~ ”操作符&lt;/li&gt;
  &lt;li&gt;“++x –x”操作符&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="c#" /><summary type="html">操作符示例 基本操作符 new 功能强大， 不能乱使用， 会造成紧耦合，依赖注入模式可以把紧耦合变成比较松的耦合， 也可以作为修饰符使用 checked, unchecked 检查是否溢出 sizeof 获取基本数据类型在内存中所占的字节 -&amp;gt; 箭头符号 通过指针的间接访问 一元操作符 &amp;amp;* 取地址符号和取引用符号 “ + - ！~ ”操作符 “++x –x”操作符</summary></entry><entry><title type="html">Adding formulas to buttons</title><link href="http://localhost:4000/2020/09/22/coda-fomular.html" rel="alternate" type="text/html" title="Adding formulas to buttons" /><published>2020-09-22T00:00:00+08:00</published><updated>2020-09-22T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/22/coda-fomular</id><content type="html" xml:base="http://localhost:4000/2020/09/22/coda-fomular.html">&lt;p&gt;&lt;a href=&quot;https://help.coda.io/en/articles/2039489-adding-formulas-to-buttons&quot;&gt;https://help.coda.io/en/articles/2039489-adding-formulas-to-buttons&lt;/a&gt;&lt;/p&gt;</content><author><name>Andy Xiong</name></author><category term="frontend" /><summary type="html">https://help.coda.io/en/articles/2039489-adding-formulas-to-buttons</summary></entry><entry><title type="html">C#语言入门详解(010)——操作符详解（上）</title><link href="http://localhost:4000/2020/09/17/c-sharp-basic-010.html" rel="alternate" type="text/html" title="C#语言入门详解(010)——操作符详解（上）" /><published>2020-09-17T00:00:00+08:00</published><updated>2020-09-17T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/17/c-sharp-basic-010</id><content type="html" xml:base="http://localhost:4000/2020/09/17/c-sharp-basic-010.html">&lt;h2 id=&quot;操作符概览&quot;&gt;操作符概览&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;操作符（Operator）也译为”运算符“&lt;/li&gt;
  &lt;li&gt;操作符用来操作数据的，被操作符操作的数据称为操作数（Operand）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;操作符的本质&quot;&gt;操作符的本质&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;操作符的本质是函数（即算法）的”简记法“&lt;/li&gt;
  &lt;li&gt;假如没有发明 ” + “， 只有Add函数， 算式 3 + 4 + 5 将可以写成Add(Add(3,4),5)&lt;/li&gt;
  &lt;li&gt;假如没有发明” x “， 只有Mul函数， 算式 3 + 4 + 5 将只能写成（Add（3，Mul(4,5)））&lt;/li&gt;
  &lt;li&gt;操作符不能脱离与它关联的数据类型&lt;/li&gt;
  &lt;li&gt;可以说操作符就是与固定数据相关联的一套基本算法的简记法&lt;/li&gt;
  &lt;li&gt;示例： 为自定义数据类型创建操作符&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;优先级和运算顺序&quot;&gt;优先级和运算顺序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;操作符的优先级&lt;/li&gt;
  &lt;li&gt;可以使用圆括号提高被括起来表达式的优先级&lt;/li&gt;
  &lt;li&gt;圆括号可以嵌套&lt;/li&gt;
  &lt;li&gt;不像数学里有方括号和花括号， C#语言里”[]“与”{}“有专门的用途&lt;/li&gt;
  &lt;li&gt;同优先级操作符的运算顺序&lt;/li&gt;
  &lt;li&gt;除了带有赋值功能的操作符， 同优先级操作符都是由左向右进行运算&lt;/li&gt;
  &lt;li&gt;带有赋值功能的运算符的运算顺序是从右向左&lt;/li&gt;
  &lt;li&gt;与数学运算不同，计算机语言的同优先级运算没有”结合率“
    &lt;ul&gt;
      &lt;li&gt;3 + 4 + 5 只能理解为Add(Add(3,4),5)不能理解为Add(3, Add(4,5))&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;各类操作符的示例&quot;&gt;各类操作符的示例&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基本操作符&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="c#" /><summary type="html">操作符概览 操作符（Operator）也译为”运算符“ 操作符用来操作数据的，被操作符操作的数据称为操作数（Operand） https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/</summary></entry><entry><title type="html">C#语言入门详解(009)——方法的定 义、调用与调试（下）</title><link href="http://localhost:4000/2020/09/13/c-sharp-basic-009.html" rel="alternate" type="text/html" title="C#语言入门详解(009)——方法的定 义、调用与调试（下）" /><published>2020-09-13T00:00:00+08:00</published><updated>2020-09-13T00:00:00+08:00</updated><id>http://localhost:4000/2020/09/13/c-sharp-basic-009</id><content type="html" xml:base="http://localhost:4000/2020/09/13/c-sharp-basic-009.html">&lt;h2 id=&quot;构造器&quot;&gt;构造器&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;构造器（constructor）是类型的成员之一
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class Student
  {
      public Student()
      {
          this.ID  = &quot;&quot;;
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;狭义的构造器指的是”实例构造器“（instance constructor）&lt;/li&gt;
  &lt;li&gt;如何调用构造器&lt;/li&gt;
  &lt;li&gt;声明构造器&lt;/li&gt;
  &lt;li&gt;构造器的内存原理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;方法的重载overload&quot;&gt;方法的重载（Overload）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;调用重载方法的示例&lt;/li&gt;
  &lt;li&gt;声明带有重载的方法
    &lt;ul&gt;
      &lt;li&gt;方法签名（method signature）由方法的名称、类型形参的个数和它的每个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。&lt;strong&gt;方法签名不包含返回类型&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;实例构造函数签名由它的每个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。&lt;/li&gt;
      &lt;li&gt;重载决策（到底调用了哪个重载）： 用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何对方法进行debug&quot;&gt;如何对方法进行debug&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;设置断点（breakpoint）&lt;/li&gt;
  &lt;li&gt;观察方法调用时的call stack&lt;/li&gt;
  &lt;li&gt;Step-in, Step-over, Step-out&lt;/li&gt;
  &lt;li&gt;观察局部变量的值和变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;方法的调用与栈&quot;&gt;方法的调用与栈&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;方法调用时栈内存的分配&lt;/li&gt;
  &lt;li&gt;对stack frame 的分析&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Andy Xiong</name></author><category term="c#" /><summary type="html">构造器 构造器（constructor）是类型的成员之一 class Student { public Student() { this.ID = &quot;&quot;; } } 狭义的构造器指的是”实例构造器“（instance constructor） 如何调用构造器 声明构造器 构造器的内存原理</summary></entry></feed>